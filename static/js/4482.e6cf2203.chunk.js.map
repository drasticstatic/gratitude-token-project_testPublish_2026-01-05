{"version":3,"file":"static/js/4482.e6cf2203.chunk.js","mappings":"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","sources":["store/interactions.js"],"sourcesContent":["/**\n * ============================================================================\n * BLOCKCHAIN INTERACTIONS MODULE\n * ============================================================================\n *\n * This module contains all functions that interact with the Ethereum blockchain.\n * It serves as the bridge between the React frontend and smart contracts.\n *\n * Key Responsibilities:\n * ---------------------\n * 1. Provider Management - Connect to Web3 provider (MetaMask, etc.)\n * 2. Contract Loading - Instantiate ethers.js Contract objects\n * 3. Token Operations - Balance queries, approvals, transfers\n * 4. AMM Operations - Swaps, liquidity deposits/withdrawals\n * 5. Crowdsale Operations - Token purchases\n * 6. Governance Contracts - Admin access, breeding lab, DAO\n *\n * Architecture Pattern:\n * ---------------------\n * Each function follows a consistent pattern:\n * 1. Accept provider/signer and dispatch function\n * 2. Perform blockchain operation\n * 3. Dispatch Redux action with result\n * 4. Return result for component use\n *\n * Error Handling:\n * ---------------\n * Functions dispatch \"Fail\" actions on errors, allowing UI to show feedback.\n * Errors are also logged to console for debugging.\n *\n * @module interactions\n */\n\nimport { ethers } from 'ethers'\n\n// Redux action creators for provider state\nimport {\n  setProvider,\n  setNetwork,\n  setAccount\n} from './reducers/provider'\n\n// Redux action creators for token state\nimport {\n  setContracts,\n  setSymbols,\n  balancesLoaded\n} from './reducers/tokens'\n\n// Redux action creators for AMM/swap state\nimport {\n  setContract,\n  sharesLoaded,\n  swapsLoaded,\n  depositRequest,\n  depositSuccess,\n  depositFail,\n  withdrawRequest,\n  withdrawSuccess,\n  withdrawFail,\n  swapRequest,\n  swapSuccess,\n  swapFail\n} from './reducers/amm'\n\n// Redux action creators for crowdsale state\nimport {\n  setCrowdsaleContract,\n  setSaleStatus,\n  setCrowdsaleStats,\n  setUserContribution,\n  buyTokensRequest,\n  buyTokensSuccess,\n  buyTokensFail\n} from './reducers/crowdsale'\n\n// Contract ABIs - Define the interface for interacting with each contract\nimport TOKEN_ABI from '../abis/Token.json';\nimport AMM_ABI from '../abis/AMM.json';\nimport CROWDSALE_ABI from '../abis/Crowdsale.json';\nimport ADMIN_ACCESS_ABI from '../abis/AdminAccess.json';\nimport BREEDING_LAB_ABI from '../abis/BreedingLab.json';\nimport DAO_GOVERNANCE_ABI from '../abis/DAOGovernance.json';\n\n// Contract addresses per network (chainId)\nimport config from '../config.json';\n\n// ============================================================================\n// PROVIDER & ACCOUNT MANAGEMENT\n// ============================================================================\n\n/**\n * Initialize Web3 Provider\n * ------------------------\n * Creates an ethers.js provider from the browser's Web3 wallet (MetaMask, etc.)\n * The provider allows read-only access to the blockchain.\n *\n * @param {Function} dispatch - Redux dispatch function\n * @returns {ethers.providers.Web3Provider} The initialized provider\n */\nexport const loadProvider = (dispatch) => {\n  const provider = new ethers.providers.Web3Provider(window.ethereum)\n  dispatch(setProvider(provider))\n\n  return provider\n}\n\n/**\n * Load Network Information\n * ------------------------\n * Queries the connected network's chain ID.\n * Used to load correct contract addresses from config.\n *\n * Common Chain IDs:\n * - 1: Ethereum Mainnet\n * - 11155111: Sepolia Testnet\n * - 31337: Hardhat Local\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {Function} dispatch - Redux dispatch function\n * @returns {number} The chain ID\n */\nexport const loadNetwork = async (provider, dispatch) => {\n  const { chainId } = await provider.getNetwork()\n  dispatch(setNetwork(chainId))\n\n  return chainId\n}\n\n/**\n * Load Connected Account\n * ----------------------\n * Requests account access from the wallet and returns the connected address.\n * This triggers the wallet's connection popup if not already connected.\n *\n * @param {Function} dispatch - Redux dispatch function\n * @returns {string} The checksummed account address\n */\nexport const loadAccount = async (dispatch) => {\n  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\n  const account = ethers.utils.getAddress(accounts[0])\n  dispatch(setAccount(account))\n\n  return account\n}\n\n// ============================================================================\n// TOKEN CONTRACT LOADING\n// ============================================================================\n\n/**\n * Load Token Contracts\n * --------------------\n * Initializes the DAPP (ETHO) and USD (PSD) token contracts.\n * These are used for swaps, donations, and other token operations.\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {number} chainId - The network chain ID\n * @param {Function} dispatch - Redux dispatch function\n */\nexport const loadTokens = async (provider, chainId, dispatch) => {\n  const dapp = new ethers.Contract(config[chainId].dapp.address, TOKEN_ABI, provider)\n  const usd = new ethers.Contract(config[chainId].usd.address, TOKEN_ABI, provider)\n\n  dispatch(setContracts([dapp, usd]))\n  dispatch(setSymbols([await dapp.symbol(), await usd.symbol()]))\n}\n\n/**\n * Load AMM Contract\n * -----------------\n * Initializes the Automated Market Maker contract for token swaps.\n * The AMM uses a constant product formula (x * y = k) for pricing.\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {number} chainId - The network chain ID\n * @param {Function} dispatch - Redux dispatch function\n * @returns {ethers.Contract} The AMM contract instance\n */\nexport const loadAMM = async (provider, chainId, dispatch) => {\n  const amm = new ethers.Contract(config[chainId].amm.address, AMM_ABI, provider)\n\n  dispatch(setContract(amm))\n\n  return amm\n}\n\n// ============================================================================\n// GOVERNANCE CONTRACT LOADING\n// ============================================================================\n\n/**\n * Load AdminAccess Contract\n * -------------------------\n * Initializes the AdminAccess contract for managing admin whitelists.\n * This contract controls who can perform administrative actions.\n *\n * Features:\n * - Multi-admin support (not just deployer)\n * - Merkle proof verification for gas-efficient whitelists\n * - On-chain admin registry\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {number} chainId - The network chain ID\n * @returns {ethers.Contract|null} The contract instance or null if not configured\n */\nexport const loadAdminAccess = async (provider, chainId) => {\n  const address = config[chainId]?.adminAccess?.address;\n  if (!address) {\n    console.warn('AdminAccess contract address not configured for chain', chainId);\n    return null;\n  }\n  return new ethers.Contract(address, ADMIN_ACCESS_ABI, provider);\n}\n\n/**\n * Load BreedingLab Contract\n * -------------------------\n * Initializes the BreedingLab contract for NFT breeding functionality.\n * Controls access to the mushroom breeding laboratory.\n *\n * Features:\n * - Whitelist-gated access\n * - Merkle proof verification\n * - Breeding pair management\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {number} chainId - The network chain ID\n * @returns {ethers.Contract|null} The contract instance or null if not configured\n */\nexport const loadBreedingLab = async (provider, chainId) => {\n  const address = config[chainId]?.breedingLab?.address;\n  if (!address) {\n    console.warn('BreedingLab contract address not configured for chain', chainId);\n    return null;\n  }\n  return new ethers.Contract(address, BREEDING_LAB_ABI, provider);\n}\n\n/**\n * Load DAOGovernance Contract\n * ---------------------------\n * Initializes the DAO governance contract for proposal and voting management.\n * This is the core contract for decentralized decision-making.\n *\n * Features:\n * - Proposal creation and voting\n * - Treasury management\n * - Whitelist-gated participation\n * - Merkle proof verification\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {number} chainId - The network chain ID\n * @returns {ethers.Contract|null} The contract instance or null if not configured\n */\nexport const loadDAOGovernance = async (provider, chainId) => {\n  const address = config[chainId]?.daoGovernance?.address;\n  if (!address) {\n    console.warn('DAOGovernance contract address not configured for chain', chainId);\n    return null;\n  }\n  return new ethers.Contract(address, DAO_GOVERNANCE_ABI, provider);\n}\n\n// ============================================================================\n// BALANCE & SHARE QUERIES\n// ============================================================================\n\n/**\n * Load Token Balances and LP Shares\n * ----------------------------------\n * Fetches the user's token balances and liquidity pool shares.\n * Balances are formatted from wei (18 decimals) to human-readable format.\n *\n * @param {ethers.Contract} amm - The AMM contract instance\n * @param {ethers.Contract[]} tokens - Array of token contracts [ETHO, PSD]\n * @param {string} account - The user's wallet address\n * @param {Function} dispatch - Redux dispatch function\n */\nexport const loadBalances = async (amm, tokens, account, dispatch) => {\n  const balance1 = await tokens[0].balanceOf(account)\n  const balance2 = await tokens[1].balanceOf(account)\n\n  dispatch(balancesLoaded([\n    ethers.utils.formatUnits(balance1.toString(), 'ether'),\n    ethers.utils.formatUnits(balance2.toString(), 'ether')\n  ]))\n\n  const shares = await amm.shares(account)\n  dispatch(sharesLoaded(ethers.utils.formatUnits(shares.toString(), 'ether')))\n}\n\n// ============================================================================\n// LIQUIDITY POOL OPERATIONS\n// ============================================================================\n\n/**\n * Add Liquidity to AMM Pool\n * -------------------------\n * Deposits tokens into the liquidity pool and receives LP shares in return.\n *\n * Process:\n * 1. Approve AMM to spend token1\n * 2. Approve AMM to spend token2\n * 3. Call addLiquidity with both amounts\n *\n * Note: First deposit sets the price ratio. Subsequent deposits must match\n * the current ratio or excess tokens are returned.\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {ethers.Contract} amm - The AMM contract instance\n * @param {ethers.Contract[]} tokens - Array of token contracts\n * @param {BigNumber[]} amounts - Array of amounts to deposit [amount1, amount2]\n * @param {Function} dispatch - Redux dispatch function\n */\nexport const addLiquidity = async (provider, amm, tokens, amounts, dispatch) => {\n  try {\n    dispatch(depositRequest())\n\n    const signer = await provider.getSigner()\n\n    let transaction\n\n    // Step 1: Approve token1 spending\n    transaction = await tokens[0].connect(signer).approve(amm.address, amounts[0])\n    await transaction.wait()\n\n    // Step 2: Approve token2 spending\n    transaction = await tokens[1].connect(signer).approve(amm.address, amounts[1])\n    await transaction.wait()\n\n    // Step 3: Add liquidity to pool\n    transaction = await amm.connect(signer).addLiquidity(amounts[0], amounts[1])\n    await transaction.wait()\n\n    dispatch(depositSuccess(transaction.hash))\n  } catch (error) {\n    dispatch(depositFail())\n  }\n}\n\n/**\n * Remove Liquidity from AMM Pool\n * ------------------------------\n * Burns LP shares and receives proportional tokens back.\n *\n * The amount of each token received is:\n * tokenAmount = (shares / totalShares) * tokenReserve\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {ethers.Contract} amm - The AMM contract instance\n * @param {BigNumber} shares - Amount of LP shares to burn\n * @param {Function} dispatch - Redux dispatch function\n */\nexport const removeLiquidity = async (provider, amm, shares, dispatch) => {\n  try {\n    dispatch(withdrawRequest())\n\n    const signer = await provider.getSigner()\n\n    let transaction = await amm.connect(signer).removeLiquidity(shares)\n    await transaction.wait()\n\n    dispatch(withdrawSuccess(transaction.hash))\n  } catch (error) {\n    dispatch(withdrawFail())\n  }\n}\n\n// ============================================================================\n// TOKEN SWAP OPERATIONS\n// ============================================================================\n\n/**\n * Swap Tokens via AMM\n * -------------------\n * Exchanges one token for another using the constant product formula.\n *\n * Pricing Formula: x * y = k\n * - x: Reserve of input token\n * - y: Reserve of output token\n * - k: Constant product (invariant)\n *\n * Output amount = (y * inputAmount) / (x + inputAmount)\n *\n * @param {ethers.providers.Web3Provider} provider - The Web3 provider\n * @param {ethers.Contract} amm - The AMM contract instance\n * @param {ethers.Contract} token - The input token contract\n * @param {string} symbol - The input token symbol (for determining swap direction)\n * @param {BigNumber} amount - Amount of input token to swap\n * @param {Function} dispatch - Redux dispatch function\n */\nexport const swap = async (provider, amm, token, symbol, amount, dispatch) => {\n  try {\n\n    dispatch(swapRequest())\n\n    let transaction\n\n    const signer = await provider.getSigner()\n\n    // Approve AMM to spend input tokens\n    transaction = await token.connect(signer).approve(amm.address, amount)\n    await transaction.wait()\n\n    if (symbol === \"DAPP\") {\n      transaction = await amm.connect(signer).swapToken1(amount)\n    } else {\n      transaction = await amm.connect(signer).swapToken2(amount)\n    }\n\n    await transaction.wait()\n\n    dispatch(swapSuccess(transaction.hash))\n\n    return transaction\n\n  } catch (error) {\n    dispatch(swapFail())\n  }\n}\n\n\n// ------------------------------------------------------------------------------\n// LOAD ALL SWAPS\n\nexport const loadAllSwaps = async (provider, amm, dispatch) => {\n  const block = await provider.getBlockNumber()\n\n  const swapStream = await amm.queryFilter('Swap', 0, block)\n  const swaps = swapStream.map(event => {\n    return { hash: event.transactionHash, args: event.args }\n  })\n\n  dispatch(swapsLoaded(swaps))\n}\n\n// ------------------------------------------------------------------------------\n// CROWDSALE INTERACTIONS\n\nexport const loadCrowdsale = async (provider, chainId, dispatch) => {\n  const crowdsale = new ethers.Contract(\n    config[chainId].crowdsale.address,\n    CROWDSALE_ABI,\n    provider\n  )\n\n  dispatch(setCrowdsaleContract(crowdsale))\n\n  return crowdsale\n}\n\nexport const loadCrowdsaleStatus = async (crowdsale, dispatch) => {\n  try {\n    const isOpen = await crowdsale.isOpen()\n    const whitelistEnabled = await crowdsale.whitelistEnabled()\n\n    dispatch(setSaleStatus({\n      isPaused: !isOpen,\n      isOpen: isOpen,\n      whitelistEnabled: whitelistEnabled\n    }))\n\n    return { isOpen, whitelistEnabled }\n  } catch (error) {\n    console.error('Error loading crowdsale status:', error)\n    return null\n  }\n}\n\nexport const loadCrowdsaleStats = async (crowdsale, dispatch) => {\n  try {\n    const tokensSold = await crowdsale.tokensSold()\n    const price = await crowdsale.price()\n\n    // Calculate total ETH raised: tokensSold * price\n    const totalRaised = tokensSold.mul(price).div(ethers.utils.parseEther('1'))\n\n    dispatch(setCrowdsaleStats({\n      totalRaised: totalRaised.toString(),\n      totalTokensSold: tokensSold.toString()\n    }))\n\n    return { totalRaised, tokensSold }\n  } catch (error) {\n    console.error('Error loading crowdsale stats:', error)\n    return null\n  }\n}\n\nexport const checkWhitelist = async (crowdsale, account, dispatch) => {\n  try {\n    const isWhitelisted = await crowdsale.whitelist(account)\n\n    dispatch(setUserContribution({\n      isWhitelisted: isWhitelisted\n    }))\n\n    return isWhitelisted\n  } catch (error) {\n    console.error('Error checking whitelist:', error)\n    return false\n  }\n}\n\nexport const loadUserContribution = async (crowdsale, account, dispatch) => {\n  try {\n    // Note: The contract doesn't track individual contributions\n    // We can only check if they're whitelisted\n    const isWhitelisted = await crowdsale.whitelist(account)\n\n    dispatch(setUserContribution({\n      amount: '0', // Contract doesn't track this\n      isWhitelisted: isWhitelisted\n    }))\n\n    return { isWhitelisted }\n  } catch (error) {\n    console.error('Error loading user contribution:', error)\n    return null\n  }\n}\n\nexport const buyTokens = async (provider, crowdsale, ethAmount, dispatch) => {\n  try {\n    dispatch(buyTokensRequest())\n\n    const signer = await provider.getSigner()\n\n    // Get price and calculate token amount\n    const price = await crowdsale.price()\n    const ethValue = ethers.utils.parseEther(ethAmount.toString())\n\n    // Calculate how many tokens for this ETH amount\n    // tokenAmount = (ethValue * 1e18) / price\n    const tokenAmount = ethValue.mul(ethers.utils.parseEther('1')).div(price)\n\n    const transaction = await crowdsale.connect(signer).buyTokens(tokenAmount, { value: ethValue })\n    await transaction.wait()\n\n    dispatch(buyTokensSuccess(transaction.hash))\n\n    return transaction\n  } catch (error) {\n    console.error('Error buying tokens:', error)\n    dispatch(buyTokensFail())\n    throw error\n  }\n}\n\n// Admin functions\nexport const addToWhitelist = async (provider, crowdsale, address) => {\n  try {\n    const signer = await provider.getSigner()\n    const transaction = await crowdsale.connect(signer).addToWhitelist(address)\n    await transaction.wait()\n    return transaction\n  } catch (error) {\n    console.error('Error adding to whitelist:', error)\n    throw error\n  }\n}\n\nexport const removeFromWhitelist = async (provider, crowdsale, address) => {\n  try {\n    const signer = await provider.getSigner()\n    const transaction = await crowdsale.connect(signer).removeFromWhitelist(address)\n    await transaction.wait()\n    return transaction\n  } catch (error) {\n    console.error('Error removing from whitelist:', error)\n    throw error\n  }\n}\n\nexport const toggleWhitelist = async (provider, crowdsale, enabled) => {\n  try {\n    const signer = await provider.getSigner()\n    const transaction = await crowdsale.connect(signer).toggleWhitelist(enabled)\n    await transaction.wait()\n    return transaction\n  } catch (error) {\n    console.error('Error toggling whitelist:', error)\n    throw error\n  }\n}\n\nexport const closeCrowdsale = async (provider, crowdsale) => {\n  try {\n    const signer = await provider.getSigner()\n    const transaction = await crowdsale.connect(signer).closeSale()\n    await transaction.wait()\n    return transaction\n  } catch (error) {\n    console.error('Error closing crowdsale:', error)\n    throw error\n  }\n}\n\nexport const openCrowdsale = async (provider, crowdsale) => {\n  try {\n    const signer = await provider.getSigner()\n    const transaction = await crowdsale.connect(signer).openSale()\n    await transaction.wait()\n    return transaction\n  } catch (error) {\n    console.error('Error opening crowdsale:', error)\n    throw error\n  }\n}\n\n// ------------------------------------------------------------------------------\n// BREEDING LAB WHITELIST OPERATIONS\nexport const addToBreedingWhitelist = async (provider, breedingLab, address) => {\n  const signer = await provider.getSigner();\n  const tx = await breedingLab.connect(signer).addToWhitelist(address);\n  await tx.wait();\n  return tx;\n}\n\nexport const removeFromBreedingWhitelist = async (provider, breedingLab, address) => {\n  const signer = await provider.getSigner();\n  const tx = await breedingLab.connect(signer).removeFromWhitelist(address);\n  await tx.wait();\n  return tx;\n}\n\nexport const setBreedingMerkleRoot = async (provider, breedingLab, merkleRoot) => {\n  const signer = await provider.getSigner();\n  const tx = await breedingLab.connect(signer).setMerkleRoot(merkleRoot);\n  await tx.wait();\n  return tx;\n}\n\nexport const checkBreedingWhitelist = async (breedingLab, address, proof = []) => {\n  return await breedingLab.isWhitelisted(address, proof);\n}\n\n// ------------------------------------------------------------------------------\n// DAO GOVERNANCE WHITELIST OPERATIONS\nexport const addToDAOWhitelist = async (provider, daoGovernance, address) => {\n  const signer = await provider.getSigner();\n  const tx = await daoGovernance.connect(signer).addToWhitelist(address);\n  await tx.wait();\n  return tx;\n}\n\nexport const removeFromDAOWhitelist = async (provider, daoGovernance, address) => {\n  const signer = await provider.getSigner();\n  const tx = await daoGovernance.connect(signer).removeFromWhitelist(address);\n  await tx.wait();\n  return tx;\n}\n\nexport const setDAOMerkleRoot = async (provider, daoGovernance, merkleRoot) => {\n  const signer = await provider.getSigner();\n  const tx = await daoGovernance.connect(signer).setMerkleRoot(merkleRoot);\n  await tx.wait();\n  return tx;\n}\n\nexport const checkDAOWhitelist = async (daoGovernance, address, proof = []) => {\n  return await daoGovernance.isWhitelisted(address, proof);\n}\n\n// ------------------------------------------------------------------------------\n// ADMIN ACCESS OPERATIONS\nexport const addAdmin = async (provider, adminAccess, address) => {\n  const signer = await provider.getSigner();\n  const tx = await adminAccess.connect(signer).addAdmin(address);\n  await tx.wait();\n  return tx;\n}\n\nexport const removeAdmin = async (provider, adminAccess, address) => {\n  const signer = await provider.getSigner();\n  const tx = await adminAccess.connect(signer).removeAdmin(address);\n  await tx.wait();\n  return tx;\n}\n\nexport const setAdminMerkleRoot = async (provider, adminAccess, merkleRoot) => {\n  const signer = await provider.getSigner();\n  const tx = await adminAccess.connect(signer).setAdminMerkleRoot(merkleRoot);\n  await tx.wait();\n  return tx;\n}\n\nexport const checkIsAdmin = async (adminAccess, address, proof = []) => {\n  if (proof.length > 0) {\n    return await adminAccess.isAdminWithProof(address, proof);\n  }\n  return await adminAccess.isAdmin(address);\n}\n\nexport const getAdminList = async (adminAccess) => {\n  return await adminAccess.getAdmins();\n}\n\n"],"names":["loadProvider","dispatch","provider","ethers","window","ethereum","setProvider","loadNetwork","async","chainId","getNetwork","setNetwork","loadAccount","accounts","request","method","account","setAccount","loadTokens","dapp","config","address","TOKEN_ABI","usd","setContracts","setSymbols","symbol","loadAMM","amm","AMM_ABI","setContract","loadAdminAccess","_config$chainId","_config$chainId$admin","adminAccess","ADMIN_ACCESS_ABI","console","warn","loadBreedingLab","_config$chainId2","_config$chainId2$bree","breedingLab","BREEDING_LAB_ABI","loadDAOGovernance","_config$chainId3","_config$chainId3$daoG","daoGovernance","DAO_GOVERNANCE_ABI","loadBalances","tokens","balance1","balanceOf","balance2","balancesLoaded","toString","shares","sharesLoaded","addLiquidity","amounts","depositRequest","signer","getSigner","transaction","connect","approve","wait","depositSuccess","hash","error","depositFail","removeLiquidity","withdrawRequest","withdrawSuccess","withdrawFail","swap","token","amount","swapRequest","swapToken1","swapToken2","swapSuccess","swapFail","loadAllSwaps","block","getBlockNumber","swaps","queryFilter","map","event","transactionHash","args","swapsLoaded","loadCrowdsale","crowdsale","CROWDSALE_ABI","setCrowdsaleContract","loadCrowdsaleStatus","isOpen","whitelistEnabled","setSaleStatus","isPaused","loadCrowdsaleStats","tokensSold","price","totalRaised","mul","div","setCrowdsaleStats","totalTokensSold","checkWhitelist","isWhitelisted","whitelist","setUserContribution","loadUserContribution","buyTokens","ethAmount","buyTokensRequest","ethValue","tokenAmount","value","buyTokensSuccess","buyTokensFail","toggleWhitelist","enabled","closeCrowdsale","closeSale","openCrowdsale","openSale","addToBreedingWhitelist","tx","addToWhitelist","removeFromBreedingWhitelist","removeFromWhitelist","setBreedingMerkleRoot","merkleRoot","setMerkleRoot","addToDAOWhitelist","removeFromDAOWhitelist","setDAOMerkleRoot","addAdmin","removeAdmin","setAdminMerkleRoot","getAdminList","getAdmins"],"sourceRoot":""}